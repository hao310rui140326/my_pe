// Copyright 2015-2017 Intel Corporation.
//
// The source code, information and material ("Material") contained herein is
// owned by Intel Corporation or its suppliers or licensors, and title to such
// Material remains with Intel Corporation or its suppliers or licensors. The
// Material contains proprietary information of Intel or its suppliers and
// licensors. The Material is protected by worldwide copyright laws and treaty
// provisions. No part of the Material may be used, copied, reproduced,
// modified, published, uploaded, posted, transmitted, distributed or disclosed
// in any way without Intel's prior express written permission. No license under
// any patent, copyright or other intellectual property rights in the Material
// is granted to or conferred upon you, either expressly, by implication,
// inducement, estoppel or otherwise. Any license under such intellectual
// property rights must be express and approved by Intel in writing.
//
// Unless otherwise agreed by Intel in writing, you may not remove or alter this
// notice or any other notice embedded in Materials by Intel or Intel's
// suppliers or licensors in any way.

#ifndef __FPGA_ARCH_H__
#define __FPGA_ARCH_H__
// -------------------------------------------------------------------------- //
// fpga_arch.h:
//
// The purpose of this file is to contain all configurable compile-time options
// for the DLA OpenCL code.
// -------------------------------------------------------------------------- //

// fpga_arch_gen.h - generated by arch_params
// defines architecture dependent parameters and parameters used in the API
#include "fpga_arch_gen.h"

#define DLA_ARCH_NAME_STRING   STR(DLA_ARCH_NAME)

#define INPUT_FEEDER_MAX_NUM_MODES        CONFIG_INPUT_FEEDER_RAM_PARAMETERS_TOTAL
#define INPUT_FEEDER_MAX_NUM_N            (NEXT_POWER_OF_2(MAX_IMAGE_BATCH_SIZE))
#define INPUT_FEEDER_MAX_NUM_PHASES       CONFIG_INPUT_FEEDER_RAM_PARAMETERS_TOTAL
#define INPUT_FEEDER_MAX_NUM_PHASE_CYCLES MAX_COUNTER_CAPACITY

#define INPUT_READER_MAX_NUM_MODES     CONFIG_INPUT_READER_RAM_PARAMETERS_TOTAL
#define INPUT_READER_MAX_NUM_N         (NEXT_POWER_OF_2(MAX_IMAGE_BATCH_SIZE))
#define INPUT_READER_MAX_NUM_PHASES    CONFIG_INPUT_READER_RAM_PARAMETERS_TOTAL
#define INPUT_READER_MAX_NUM_CVEC      MAX_COUNTER_CAPACITY
#define INPUT_READER_MAX_NUM_H         MAX_COUNTER_CAPACITY
#define INPUT_READER_MAX_NUM_WW        MAX_COUNTER_CAPACITY

#define OUTPUT_WRITER_MAX_NUM_MODES    CONFIG_OUTPUT_WRITER_RAM_PARAMETERS_TOTAL
#define OUTPUT_WRITER_MAX_NUM_N        (NEXT_POWER_OF_2(MAX_IMAGE_BATCH_SIZE))
#define OUTPUT_WRITER_MAX_NUM_PHASES   CONFIG_OUTPUT_WRITER_RAM_PARAMETERS_TOTAL

#define ACTIVATION_MAX_NUM_KVEC              (NEXT_POWER_OF_2(NEXT_DIVISIBLE((output_channels_max+NORM_SHIFT_K), K_VECTOR)))
#define ACTIVATION_MAX_NUM_HVEC              (NEXT_POWER_OF_2(output_image_height_max))
#define ACTIVATION_MAX_NUM_WVEC              (NEXT_POWER_OF_2(output_image_width_max))

// LSTM DERIVED PARAMETERS

// how much of the "image"/"batch" do we process in 1 cycle
#define LSTM_BATCH_VEC (P_VECTOR*Q_VECTOR)

// batching in width and height
#define MAX_BATCH_SIZE_WIDTH_LSTM Q_VECTOR

// full depth of context cache including batching
#define LSTM_CONTEXT_CACHE_FULL_DEPTH (LSTM_CONTEXT_CACHE_DEPTH*MAX_LSTM_NUM_STREAMS/LSTM_BATCH_VEC)

// END LSTM DERIVED PARAMETERS

// AUX Precision Parameters

#if defined(AUX_FP16)
  #define AUX_DATA_VALUE_SIZE_IN_BYTES            2
  #define AUX_DATA_VALUE_MANTISSA_WIDTH           10
#elif defined(AUX_FP11)
  #define AUX_DATA_VALUE_SIZE_IN_BYTES            2
  #define AUX_DATA_VALUE_MANTISSA_WIDTH           5
#elif defined(AUX_FP10)
  #define AUX_DATA_VALUE_SIZE_IN_BYTES            2
  #define AUX_DATA_VALUE_MANTISSA_WIDTH           4
#elif defined(AUX_FP9)
  #define AUX_DATA_VALUE_SIZE_IN_BYTES            2
  #define AUX_DATA_VALUE_MANTISSA_WIDTH           3
#elif defined(AUX_FP8)
  #define AUX_DATA_VALUE_SIZE_IN_BYTES            2
  #define AUX_DATA_VALUE_MANTISSA_WIDTH           2
#else
  #error
#endif

#if defined(USE_FP11)

  #define USE_FP16_POW_075_EFI_IN_NORM

  #define BLOCKFP_FILTER_TRANSFORM_MAX_SHIFT  7
  #define BLOCKFP_INPUT_TRANSFORM_MAX_SHIFT   16

  #ifndef BLOCKFP_FILTER_TRANSFORM_WIDTH
    #define BLOCKFP_FILTER_TRANSFORM_WIDTH   7
  #endif

  #ifndef BLOCKFP_INPUT_TRANSFORM_WIDTH
    #define BLOCKFP_INPUT_TRANSFORM_WIDTH    12
  #endif

  #define BLOCKFP_OUTPUT_TRANSFORM_WIDTH     16

  #define DATA_VALUE_SIZE_IN_BYTES      2

  #define BLOCKFP_DATA_VALUE_MANTISSA_WIDTH 5

#elif defined(USE_FP10)

  #define USE_FP16_POW_075_EFI_IN_NORM

  #define BLOCKFP_FILTER_TRANSFORM_MAX_SHIFT  7
  #define BLOCKFP_INPUT_TRANSFORM_MAX_SHIFT   7

  #ifndef BLOCKFP_FILTER_TRANSFORM_WIDTH
    #define BLOCKFP_FILTER_TRANSFORM_WIDTH   6
  #endif

  #ifndef BLOCKFP_INPUT_TRANSFORM_WIDTH
    #define BLOCKFP_INPUT_TRANSFORM_WIDTH    6
  #endif

  #define BLOCKFP_OUTPUT_TRANSFORM_WIDTH     16

  #define DATA_VALUE_SIZE_IN_BYTES      2

  #define BLOCKFP_DATA_VALUE_MANTISSA_WIDTH 4

#elif defined(USE_FP9)

  #define USE_FP16_POW_075_EFI_IN_NORM

  #define BLOCKFP_FILTER_TRANSFORM_MAX_SHIFT  7
  #define BLOCKFP_INPUT_TRANSFORM_MAX_SHIFT   7

  #ifndef BLOCKFP_FILTER_TRANSFORM_WIDTH
    #define BLOCKFP_FILTER_TRANSFORM_WIDTH   5
  #endif

  #ifndef BLOCKFP_INPUT_TRANSFORM_WIDTH
    #define BLOCKFP_INPUT_TRANSFORM_WIDTH    5
  #endif

  #define BLOCKFP_OUTPUT_TRANSFORM_WIDTH     16

  #define DATA_VALUE_SIZE_IN_BYTES      2

  #define BLOCKFP_DATA_VALUE_MANTISSA_WIDTH 3

#elif defined(USE_FP8)

  #define USE_FP16_POW_075_EFI_IN_NORM

  #define BLOCKFP_FILTER_TRANSFORM_MAX_SHIFT  7
  #define BLOCKFP_INPUT_TRANSFORM_MAX_SHIFT   7

  #ifndef BLOCKFP_FILTER_TRANSFORM_WIDTH
    #define BLOCKFP_FILTER_TRANSFORM_WIDTH   4
  #endif

  #ifndef BLOCKFP_INPUT_TRANSFORM_WIDTH
    #define BLOCKFP_INPUT_TRANSFORM_WIDTH    4
  #endif

  #define BLOCKFP_OUTPUT_TRANSFORM_WIDTH     16

  #define DATA_VALUE_SIZE_IN_BYTES      2

  #define BLOCKFP_DATA_VALUE_MANTISSA_WIDTH 2

#elif defined(USE_FP16)

  #define USE_FP16_POW_075_EFI_IN_NORM

  #define BLOCKFP_FILTER_TRANSFORM_MAX_SHIFT  12
  #define BLOCKFP_INPUT_TRANSFORM_MAX_SHIFT   12

  #ifndef BLOCKFP_FILTER_TRANSFORM_WIDTH
    #define BLOCKFP_FILTER_TRANSFORM_WIDTH   12
  #endif

  #ifndef BLOCKFP_INPUT_TRANSFORM_WIDTH
    #define BLOCKFP_INPUT_TRANSFORM_WIDTH    12
  #endif

  #define BLOCKFP_OUTPUT_TRANSFORM_WIDTH     16

  #define DATA_VALUE_SIZE_IN_BYTES      2

  #define BLOCKFP_DATA_VALUE_MANTISSA_WIDTH 10

#else
  #error
#endif

#ifdef INTELFPGA_CL
#ifndef EFI_LIB
#ifdef ENABLE_CONV
CONSTANT bool enable_conv = true;
#else
CONSTANT bool enable_conv = false;
#endif

#ifdef ENABLE_PERF_COUNTERS
CONSTANT bool enable_perf_counters = true;
#else
CONSTANT bool enable_perf_counters = false;
#endif

constant int norm_pool_tiled_height_max = output_image_height_max + POOL_SHIFT_P_MAX;
constant int norm_pool_tiled_width_max = output_image_width_max + POOL_SHIFT_Q_MAX;

constant int num_cvec_max = MYCEIL(output_channels_max, C_VECTOR);
constant int num_kvec_max = MYCEIL(output_channels_max, K_VECTOR);
constant int norm_pool_tiled_depth_max = output_channels_max + NORM_SHIFT_K;
#endif
// this define should be enabled if NORM_BETA is equal to 0.75f, it turns on
// an optimized implementation that uses less DSPs
#define NORM_BETA_075

// window over which to normalize
// TODO: this should be reconfigurable parameter set for the specific topology
#define NORM_WINDOW 5

// number of operands in an eltwise layer
// TODO: make it a configurable parameter
#define NUM_ELTWISE_OPERANDS 2

#define KERNELS_TO_BANK_RATIO ( MYCEIL( K_VECTOR, C_VECTOR ) )

// used for input_cache and filter_cache banking that uses NEXT_POWER_OF_2 macro
#if C_VECTOR > 512
#error "C_VECTOR must be <= 512"
#endif

// used for input_cache and filter_cache banking that uses NEXT_POWER_OF_2 macro
#if K_VECTOR > 512
#error "K_VECTOR must be <= 512"
#endif

#if C_VECTOR > K_VECTOR
#error "C_VECTOR must be <= K_VECTOR"
#endif

#ifdef ENABLE_ELTWISE_INPUT_INTERLEAVE
#if (C_VECTOR % NUM_ELTWISE_OPERANDS) != 0
#error "C_VECTOR must be a multiple of NUM_ELTWISE_OPERANDS for eltwise input interleaving to be enabled"
#endif
#endif

#endif // INTELFPGA_CL

// Constant value arithmetic constraints

// C_VECTOR constaints
#if IS_POWER_OF_2(C_VECTOR) == false
#error "C_VECTOR must be power-of-2 for properly optimized constant arithmetic"
#endif

// LSTM_BLOCK currently doesn't work with other aux kernels
#if defined(ENABLE_LSTM_BLOCK) && (defined(ENABLE_NORM) || defined(ENABLE_POOL))
#error "LSTM block has not been tested with any other auxilliary kernels"
#endif

// ReLU, Leaky ReLU and pReLU are mutually exclusive
#if defined(ENABLE_RELU) + defined(ENABLE_LEAKY_RELU) + defined(ENABLE_PRELU) + defined(ENABLE_SCALESHIFT) > 1
#error "Can only have one of ReLU, Leaky ReLU, pReLU, and ScaleShift in an arch. Only use the most permissive."
#endif

#endif // __FPGA_ARCH_H__
